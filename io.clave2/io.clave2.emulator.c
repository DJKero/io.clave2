#include <Windows.h>

#include "../kitchen_sink/kitchen_sink.h"
#include "io.clave2.protocol.h"
#include "io.clave2.emulator.h"

static struct _EClave2Session {
    unsigned char session_key[16];
    unsigned char request_buffer[69];
    unsigned char response_buffer[69];
}EClave2Session;


static struct _EClave2 {
    char path_to_ini[1024];
    char profile_name[64];
    char developer_id[5];
    wchar_t serial[32];
    char password[9];
    unsigned char mem_page_0[512];
}EClave2;

BOOL LC_Crypt(unsigned char* request_buffer, unsigned char* response_buffer) {
    char in_data_str[64] = { 0x00 };
    char out_data_str[64] = { 0x00 };
    BinToHex(request_buffer, 0x10, in_data_str, sizeof(in_data_str));
    if (!GetPrivateProfileStringA(EClave2.profile_name, in_data_str, NULL, out_data_str, sizeof(out_data_str), EClave2.path_to_ini)) {
        DBG_printfA("[io.clave2]: LC_CRYPT [FAIL]: %s->?", in_data_str);
        return FALSE;
    }
    DBG_printfA("[io.clave2]: LC_CRYPT: %s->%s", in_data_str, out_data_str);
    HexToBin(out_data_str, response_buffer, 16);
    return TRUE;
}

int FindDongleWindows() {
    char current_data[2048] = { 0x00 };
    // Copy the First 4 characters of the serial.

    // Final format [SERL_PASSWORD]
    if (!GetPrivateProfileStringA("CLAVE2_PROFILES", EClave2.password, "", EClave2.profile_name, sizeof(EClave2.profile_name), EClave2.path_to_ini)) {
        // Couldn't Find the Right Dongle Data :(
        DBG_printfA("[io.clave2]: Error - Dongle Not Found: %s", EClave2.profile_name);
        return FALSE;
    }
    // Load The Rest of Everything.
    if (GetPrivateProfileStringA(EClave2.profile_name, "mem_page_0", NULL, current_data, 2048, EClave2.path_to_ini)) {
        HexToBin(current_data, EClave2.mem_page_0, 512);
    }
    else {
        memset(EClave2.mem_page_0, 0xFF, sizeof(EClave2.mem_page_0));
    }

    DBG_printfW(L"[io.clave2]: Loaded Emulated CLAVE2");
    DBG_printfA("[io.clave2]: Developer ID: %s", EClave2.developer_id);
    DBG_printfW(L"[io.clave2]: Serial: %s", EClave2.serial);
    DBG_printfA("[io.clave2]: Password: %s", EClave2.password);
    DBG_printfW(L"[io.clave2]: Mem Page 0: ");
    DBG_print_buffer(EClave2.mem_page_0, sizeof(EClave2.mem_page_0));
    return TRUE;
}


BOOL LC_Transact() {
    // If this isn't a session packet, we'll have to decrypt it first.
    DWORD req_header = *(DWORD*)EClave2Session.request_buffer;
    BOOL encode_output = TRUE;
    if (req_header == 0x00CD0B00) {
        GenerateExchangeKey(EClave2Session.request_buffer+5,EClave2Session.session_key);
        encode_output = FALSE;
    }
    else {
        EncodeDecodeBuffer(EClave2Session.request_buffer, sizeof(EClave2Session.request_buffer), EClave2Session.session_key);
    }
    //DBG_print_buffer(EClave2Session.request_buffer, 69);
    memset(EClave2Session.response_buffer, 0x00, sizeof(EClave2Session.response_buffer));
    WORD offset = 0;
    BYTE amt = 0;
    char login_password[9] = { 0x00 };
    switch (EClave2Session.request_buffer[1]) {
        case OP_SESSION:
            EClave2Session.response_buffer[2] = 0xCD;
            break;
        case OP_AUTHENTICATION:
            switch (EClave2Session.request_buffer[2]) {
                case LOGIN_USER:
                case LOGIN_ADMIN:
                case LOGIN_AUTH:
                    EClave2Session.response_buffer[2] = LOGIN_USER;
                    memcpy(EClave2.password, EClave2Session.request_buffer + 5, 8);
                    if (!FindDongleWindows()) {
                        EClave2Session.response_buffer[1] = 0x0C;
                    }
                    break;
                case LOGOUT:
                    EClave2Session.response_buffer[2] = LOGOUT;
                    break;
            }
            break;
        case OP_HW_INFO:
            EClave2Session.response_buffer[4] = 0x20;
            memcpy(EClave2Session.response_buffer + 5, EClave2.serial, 24);
            break;
        case OP_CONVERT:
            switch (EClave2Session.request_buffer[2]) {
                case CONVERT_ENCRYPT:
                    EClave2Session.response_buffer[2] = CONVERT_ENCRYPT;
                    break;
                case CONVERT_DECRYPT:
                    EClave2Session.response_buffer[2] = CONVERT_DECRYPT;
                    break;
            }
            EClave2Session.response_buffer[4] = 0x10;
            if (!LC_Crypt(EClave2Session.request_buffer + 5, EClave2Session.response_buffer + 5)) {
                DBG_printfW(L"[io.clave2]: Error During OP_CONVERT - Missing Key!");

            }
            break;
        case OP_READ:
            offset = _byteswap_ushort(*(WORD*)(EClave2Session.request_buffer + 2));
            *(WORD*)(EClave2Session.response_buffer + 2) = offset;
            amt = EClave2Session.request_buffer[4];
            DBG_printfW(L"[io.clave2]: Reading From Memory: %04X %d", offset, amt);
            EClave2Session.response_buffer[4] = amt;
            memcpy(EClave2Session.response_buffer + 5, EClave2.mem_page_0 + offset, amt);
            break;
        default:
            break;
    }

    //DBG_print_buffer(EClave2Session.response_buffer, 69);
    // We have to encode the response packet if we aren't in session mode.
    if (encode_output) {
        EncodeDecodeBuffer(EClave2Session.response_buffer, sizeof(EClave2Session.response_buffer), EClave2Session.session_key);
    }
    return TRUE;
}



void GetSerialNumberWstr(wchar_t* serial_wstr) {
    wcscpy(serial_wstr, EClave2.serial);
}



unsigned char hid_collection_descriptor[0x254] = {
        0x48, 0x69, 0x64, 0x50, 0x20, 0x4B, 0x44, 0x52, 0x01, 0x00, 0xA0, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x09, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x02, 0x00, 0x04, 0x00, 0x45, 0x00, 0xA0, 0x01, 0x02, 0x00, 0xA1, 0xFF, 0x00, 0x00,
        0x08, 0x00, 0x07, 0x00, 0x02, 0x00, 0x38, 0x00, 0x02, 0x00, 0x00, 0x00, 0x09, 0x00, 0x01, 0x00,
        0xA0, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF,
        0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xA1, 0xFF, 0x00, 0x00, 0x08, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0xA0, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 0xFF, 0x00, 0x00,
        0x08, 0x00, 0x43, 0x00, 0x02, 0x00, 0x18, 0x02, 0x02, 0x00, 0x00, 0x00, 0x45, 0x00, 0x01, 0x00,
        0xA0, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF,
        0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xA1, 0xFF, 0x00, 0x00, 0x08, 0x00, 0x01, 0x00, 0x01, 0x00, 0x08, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0xA0, 0xFF, 0x02, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xA0, 0xFF,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0xA0, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
};

typedef struct _HID_COLLECTION_INFORMATION {
    ULONG   DescriptorSize;
    BOOLEAN Polled;
    UCHAR   Reserved1[1];
    USHORT  VendorID;
    USHORT  ProductID;
    USHORT  VersionNumber;
} HID_COLLECTION_INFORMATION, *PHID_COLLECTION_INFORMATION;
static HID_COLLECTION_INFORMATION hci;

void ProcessClave2IoctlWindows(unsigned int IoControlCode, unsigned char* InputBuffer,unsigned int InputBufferLength,unsigned char* OutputBuffer,unsigned int OutputBufferLength){
    switch (IoControlCode) {
        case IOCTL_HID_GET_FEATURE:
            memcpy(OutputBuffer, EClave2Session.response_buffer, 69);
            break;
        case IOCTL_HID_SET_FEATURE:
            memcpy(EClave2Session.request_buffer, InputBuffer, 69);
            LC_Transact();
            break;
        case IOCTL_HID_GET_SERIALNUMBER_STRING:
            GetSerialNumberWstr((wchar_t*)OutputBuffer);
            DBG_printfW(L"[io.clave2]: Wrote Serial: %s", OutputBuffer);
            break;
        case IOCTL_HID_GET_COLLECTION_INFORMATION:
            memcpy(OutputBuffer, &hci, sizeof(hci));
            break;
        case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
            memcpy(OutputBuffer, hid_collection_descriptor, sizeof(hid_collection_descriptor));
            break;
        default:
            DBG_printfW(L"[io.clave2]: Clave2 Unhandled IOCTL: %04X", IoControlCode);
            DBG_print_buffer(OutputBuffer, OutputBufferLength);
            break;
    }
}

int InitClave2EmuWindows(char* ini_path) {

    char current_data[2048] = { 0x00 };
    hci.DescriptorSize = sizeof(hid_collection_descriptor);
    hci.Polled = 0x00;
    hci.Reserved1[0] = 0x00;
    hci.VendorID = 0x1BC0;
    hci.ProductID = 0x8101;
    hci.VersionNumber = 0x100;


    strcpy(EClave2.path_to_ini, ini_path);
    GetPrivateProfileStringA("CLAVE2_OPTIONS", "serial", "123456123456", current_data, 2048, EClave2.path_to_ini);
    memset(EClave2.developer_id,0x00, sizeof(EClave2.developer_id));
    memcpy(EClave2.developer_id, current_data, 4);
    AsciiToWide((unsigned char*)current_data, strlen(current_data) + 1, (unsigned char*)EClave2.serial, 0);
    return TRUE;
}